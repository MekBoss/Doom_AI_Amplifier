extend class node_base
{

array_wrapper flood_search(node_base beginning = null, node_base end = null, actor walker = null, bool debug_mode = false)
{
    let full_path = array_wrapper(new("array_wrapper"));

    //nothing to begin with
    if(beginning == null)
        return full_path;

    //if there are no goal
    if(end == null)
    {
        //check, maybe it need runned in debug mode
        if(debug_mode == true)
        {}

        //if no, return
        else
            return full_path;
    }

    //because in debug we dotn have goal
    if(!debug_mode)
    {
        //nodes in different groups, return now
        if( beginning.check_connectivity_to(end) == false )
            return full_path;
    }

    //fuse
    uint size = 0;

    //for already processed nodes
    array<node_base> processed_nodes; processed_nodes.clear();

    //for nodes in processing
    array<node_base> processing_nodes; processing_nodes.clear();

    //for nodes which would be processed in the next step
    array<node_base> unprocessed_nodes; unprocessed_nodes.clear();

    //we need something to begin with
    processing_nodes.push(beginning);

    //precaution, so it wont go into infinity, UNBOUNDED, T R A N S C E N D E N T A L loop
    while(size < path_algorithm(all_graph_list).graph_size() )
    {
        //actually which
        bool witch = false;
        
        while(!witch)
        {
            
            if(processing_nodes.size() <= 0)
                processing_nodes.copy(unprocessed_nodes);

            //if even after previous action array stil empty
            //we out of nodes 
            if(processing_nodes.size() <= 0)
            {
                witch = true;
                size = path_algorithm(all_graph_list).graph_size();
                continue;
            }

            for(uint i = 0; i < processing_nodes.size(); i++)
            {
                node_base(processing_nodes[i]).set_processed();

                processed_nodes.push(node_base(processing_nodes[i]) );

                let unmarked = array_wrapper( node_base(processing_nodes[i]).get_unmarked_neighborgs() );

                //dont check bools because previous function already do such check
                for(uint j = 0; j < unmarked.path.size(); j++)
                {
                    //is line block moving
                    if(is_line_passable( processing_nodes[i].line_between_sectors(unmarked.path[i]), walker) == false)
                    {
                        //no, return now
                        //probably there are another way
                        continue;
                    }

                    if(processing_nodes[i].is_sector_passable( unmarked.path[i], walker, debug_mode) == false)
                    {
                        node_base(unmarked.path[i]).set_processed();

                    }
                }
            }

            processing_nodes.clear();
            processing_nodes.copy(unprocessed_nodes);
        }

        size++;
    }

    //clear all marks
    //for every node group
    for(uint i = 0; i < processed_nodes.size(); i++)
    {
        node_base(processed_nodes[i]).set_unprocessed();
    }

    return full_path;

}

}