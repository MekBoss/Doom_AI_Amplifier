

class pathfinding_thinker : thinker
{
//monster
private actor blind_kitten;
private actor pseudotarget;

private linetracer sight_check;


private eventhandler nodes;

private array_wrapper path;

private bool have_path, reach_target, cant_move_out, shooting;

//update path for every 10 second
private uint update_timer;

void init(actor a, eventhandler e)
{
    blind_kitten = a;
    nodes = e;
    sight_check = new("target_checker");
    update_timer = 0;
}

private bool is_real_target()
{
    if(blind_kitten)
    {
        if(blind_kitten.target != null && blind_kitten.target != pseudotarget )
            return true;
    
        else    
            return false;
    }
    return false;
}

private void rearrange_target()
{
    if(blind_kitten && pseudotarget)
    {
        pseudotarget.target = blind_kitten.target;
        pseudotarget.master = blind_kitten;

        blind_kitten.target = pseudotarget;
        blind_kitten.lastheard = pseudotarget;
        blind_kitten.lastenemy = pseudotarget;

        pseudotarget.setorigin(pseudotarget.target.pos, false);
    }
}

//create path from A to B
private void get_path()
{
    if(blind_kitten && pseudotarget)
    {
        node_base cur_node = path_algorithm(nodes).sector_to_node(blind_kitten.cursector);
        node_base targ_node = path_algorithm(nodes).sector_to_node(pseudotarget.target.cursector);
        
        //console.printf("id is %i and %i", node_base(cur_node).get_id(), node_base(targ_node).get_id() );
        
        if(cur_node && targ_node) 
            path = node_base(cur_node).dj_search(cur_node, targ_node, blind_kitten);

        else
            console.printf("some node does not exist");
    }
}

//check is line is blocking
private bool is_line_blocking(line l)
{
    if(l)
    {
        if( (l.flags & l.ML_BLOCKING)
        || (l.flags &  line.ML_BLOCKMONSTERS)
        || (l.flags & line.ML_BLOCKEVERYTHING)
        || !(l.flags & line.ML_TWOSIDED) )
            return true;
    }
    return false;
}



//if monster bump into impassable line
//rotate it in "correct" direction (closer to destination node while staying in the same sector)
private void rotate_kitten(line l)
{
    if(l)
    {
        vector2 a, b, midline, direction, offset;

        midline = (l.v1.p + l.v2.p) / 2;

        direction = l.v1.p - midline;
        offset = direction;
        //get almost unit vector but in much more cheaper way
        if(abs(offset.x) > abs(offset.y) || abs(offset.x) == abs(offset.y) )
            offset /= abs(offset.x);
        else
            offset /= abs(offset.y);

        a = midline + (direction + offset);

        b = midline - (direction + offset);

        actor.spawn("healthbonus", pos: (a, 0));
        actor.spawn("healthbonus", pos: (b, 0));

        //if both points in the same sector
        if(level.PointInSector(a) == blind_kitten.cursector && level.PointInSector(b) == blind_kitten.cursector)
        {
            vector2 aa = level.vec2diff(a, pseudotarget.pos.xy);
            vector2 bb = level.vec2diff(b, pseudotarget.pos.xy);

            double a_dis = aa dot aa;
            double b_dis = bb dot bb;

            if(a_dis == b_dis)
            {
                //repeat calculation slightly changing vectors
                aa = level.vec2diff(a, pseudotarget.pos.xy + (1, 1) );
                bb = level.vec2diff(b, pseudotarget.pos.xy + (1, 1) );

                a_dis = aa dot aa;
                b_dis = bb dot bb;

            }

            else if( a_dis < b_dis )
            {
                if(direction.x == 0)
                {
                    if( direction.y > 0 )
                        blind_kitten.angle = 90;
                    else
                        blind_kitten.angle = -90;
                }
                else
                    blind_kitten.angle = atan(direction.y / direction.x);
            }

            else
            {
                if(direction.x == 0)
                {
                    if( direction.y > 0 )
                        blind_kitten.angle = -90;
                    else
                        blind_kitten.angle = 90;
                }
                else
                    blind_kitten.angle = atan( - direction.y / - direction.x);
            }
        }

        else if (level.PointInSector(a) == blind_kitten.cursector)
        {
            if(direction.x == 0)
            {
                if( direction.y > 0 )
                    blind_kitten.angle = 90;
                else
                    blind_kitten.angle = -90;
            }
            else
                blind_kitten.angle = atan(direction.y / direction.x);
        }

        else
        {
            if(direction.x == 0)
            {
                if( direction.y > 0 )
                    blind_kitten.angle = -90;
                else
                    blind_kitten.angle = 90;
            }
            else
                blind_kitten.angle = atan( - direction.y / - direction.x);
        }
    }
}

//check is actor hit/near some line
private void check_line_crashing(actor it)
{
    if(!it)
        it = blind_kitten;
    
    for(uint i = 0; i < it.cursector.lines.size(); i++)
    {
        let l = it.cursector.lines[i];

        if(is_inside_line_bbox(it, l) )
        {
            //check is line actually block actor
            if( is_line_blocking(l) )
            {
                //then rotate monster to vertex which closer to destination node
                rotate_kitten(l);
            }
        }
    }
}

//check line bbox and return true if actor, near/in it
private bool is_inside_line_bbox(actor t, line l)
{
    //is inside line bounding rectangle
    //radius and -5 to extend bbox of vertical/horizontal lines
    //which have zero width/height of bbox
    if(t.pos.x > l.bbox[0] - t.radius - 5 && t.pos.x < l.bbox[1] - t.radius - 5 )
    {
        if(t.pos.y > l.bbox[2] - t.radius - 5 && t.pos.y < l.bbox[3] - t.radius - 5 )
        {
            //yes
            return true;
        }
    }

    //same, but now with +
    if(t.pos.x > l.bbox[0] + t.radius + 5 && t.pos.x < l.bbox[1] + t.radius + 5 )
    {
        if(t.pos.y > l.bbox[2] + t.radius + 5 && t.pos.y < l.bbox[3] + t.radius + 5 )
        {
            //yes
            return true;
        }
    }
    return false;
}

//what function name says
private bool is_actual_target_in_fov()
{
    vector3 hit_dir = level.vec3diff(blind_kitten.pos, pseudotarget.target.pos);

    target_checker(sight_check).actual_target = pseudotarget.target;
    sight_check.trace(blind_kitten.pos + (0, 0, blind_kitten.height / 2), blind_kitten.cursector, hit_dir, 8192, TRACE_HitSky);

    //yes, proceed to shooting
    if(target_checker(sight_check).success == true)
        return true;

    //go back to default monsters buisenes, like dancing on spawn spot
    else
        return false;
}

override void tick()
{
    if(!pseudotarget)
    {
        pseudotarget = actor.spawn("blind_kitten_target", (double.infinity, double.infinity, double.infinity) );
    }

    //if alive, in some term, and have target
    if(blind_kitten && (blind_kitten.health > 0 || blind_kitten.bkilled == false || blind_kitten.bICECORPSE == false) && blind_kitten.target)
    {
        if(shooting == false)
        {
            if(is_real_target() == true)
            {
                rearrange_target();
            }
            
            //monster target already changed to mod related target
            //if it location dont equal to monster location, and if there are no path to it
            if( (blind_kitten.target.cursector != blind_kitten.cursector && path == null))
            {
                get_path();
            }
            //or 5 second pass and target, probably, change it sector
            if( update_timer > 175)
            {
                get_path();
                update_timer = 0;
            }

            //follow path here
            if( path )
            {
                if( array_wrapper(path).path.size() > 0)
                {
                    uint last_element = array_wrapper(path).path.size() - 1;

                    pseudotarget.setorigin( node_base(array_wrapper(path).path[last_element]).get_center(), false );

                    //destroy last node in array if it location equal to monster
                    //and there are still some nodes to follow
                    if(blind_kitten.cursector == array_wrapper(path).path[last_element].get_sector() )
                    {
                        array_wrapper(path).path.pop();
                    }

                    //check blocking here
                    if(blind_kitten.BlockingLine != null)
                    {
                        //dont work for SOME REASON!!!!!!!!!!!!!11111 AAAAAAAAAAAAAAAAAAAAAAAAAAAA
                        //function on c++ side cant be forced to activate line without some mandatory checks
                        //which would fails because monster is not player/dont have key/etc. etc. etc.
                        //my disappointment is immeasurable and my day is ruined :(
                        if(blind_kitten.BlockingLine.activation > 0)
                            blind_kitten.BlockingLine.Activate(blind_kitten, 0, SPAC_MUse);

                        check_line_crashing(blind_kitten);

                        if(array_wrapper(path).path_lines.size() > 0)
                        {
                            if(blind_kitten.BlockingLine == array_wrapper(path).path_lines[array_wrapper(path).path_lines.size() - 1] )
                            {
                                array_wrapper(path).path_lines.pop();
                            }
                        }
                    }
                }
                //no points to follow
                else
                    path.destroy();
           }

            if(!path)
            {
                blind_kitten.target = pseudotarget.target;
            }
        }

        //monster want shoot someone, do some technical checks here to allow/prevent it
        if(shooting == true || blind_kitten.instatesequence(blind_kitten.curstate, blind_kitten.findstate("missile") ) || blind_kitten.instatesequence(blind_kitten.curstate, blind_kitten.findstate("melee") ) )
        {
            //init shooting sequence
            if(shooting == false)
            {
                //check is there are line of sight with monster target
                //yes, proceed to shooting
                if(is_actual_target_in_fov() == true)
                {
                    blind_kitten.meleerange = blind_kitten.default.meleerange;
                    blind_kitten.target = pseudotarget.target;
                    blind_kitten.a_facetarget();
                    //shooting = true;
                }
                //otherwise, target behind wall, go back to folowing path
                //by preventing any attack chance
                else
                {
                    blind_kitten.meleerange = double.infinity;
                    blind_kitten.bJUSTATTACKED = true;
                    blind_kitten.reactiontime = 16;
                    blind_kitten.setstate(blind_kitten.findstate("see"));
                }
            }
/*
            this make monsters too strong

            //already shooting
            //if next state is see state, i.e. it already stop shooting
            if (blind_kitten.instatesequence(blind_kitten.curstate.nextstate, blind_kitten.findstate("see") ) )
            {
                //if target alive and cvar say continue shoot
                if(blind_kitten.target.bkilled == false && monster_constant_shooting == true)
                {
                    //if target in fov of course
                    if(is_actual_target_in_fov() == false)
                    {
                        blind_kitten.target = pseudotarget;
                        shooting = false;
                    }

                    else
                        blind_kitten.setstatelabel("missile");
                }
            }
*/            
        }
    }

    //increase timer
    update_timer ++;

    //obvious
    if(!blind_kitten)
    {
        pseudotarget.destroy();
        self.destroy();
        if(sight_check)
            sight_check.destroy();
        if(path)
            path.destroy();
    }
}

}





class blind_kitten_target : actor
{

default
{
    +noclip
    +nointeraction
    +nosector
    +shootable
    height 10;
    radius 10;
}

states
{
    spawn:
        tnt1 a -1;
    stop;
}

}


class target_checker : LineTracer
{
Actor actual_target;
bool success;

override ETraceStatus TraceCallback()
{
    if (Results.HitType == TRACE_HitWall)
    {
        if (Results.Tier == TIER_Middle)
        {
            if (Results.HitLine.Flags & Line.ML_TWOSIDED)
            {
                return TRACE_Skip;
            }
            return TRACE_Stop; 
        }
    }

    if (Results.HitType == TRACE_HitActor)
    {
        success = false;
        if (Results.HitActor == actual_target)
        {
            success = true;
            return TRACE_Stop;
        }
        return TRACE_skip;
    }
    return TRACE_Stop;
}

}

